{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/SobelOperatorShader.js"],
  "sourcesContent": ["import {\r\n\tVector2\r\n} from 'three';\r\n\r\n/**\r\n * Sobel Edge Detection (see https://youtu.be/uihBwtPIBxM)\r\n *\r\n * As mentioned in the video the Sobel operator expects a grayscale image as input.\r\n *\r\n */\r\n\r\nconst SobelOperatorShader = {\r\n\r\n\tuniforms: {\r\n\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'resolution': { value: new Vector2() }\r\n\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvUv = uv;\r\n\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform vec2 resolution;\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\r\n\t\t\tvec2 texel = vec2( 1.0 / resolution.x, 1.0 / resolution.y );\r\n\r\n\t\t// kernel definition (in glsl matrices are filled in column-major order)\r\n\r\n\t\t\tconst mat3 Gx = mat3( -1, -2, -1, 0, 0, 0, 1, 2, 1 ); // x direction kernel\r\n\t\t\tconst mat3 Gy = mat3( -1, 0, 1, -2, 0, 2, -1, 0, 1 ); // y direction kernel\r\n\r\n\t\t// fetch the 3x3 neighbourhood of a fragment\r\n\r\n\t\t// first column\r\n\r\n\t\t\tfloat tx0y0 = texture2D( tDiffuse, vUv + texel * vec2( -1, -1 ) ).r;\r\n\t\t\tfloat tx0y1 = texture2D( tDiffuse, vUv + texel * vec2( -1,  0 ) ).r;\r\n\t\t\tfloat tx0y2 = texture2D( tDiffuse, vUv + texel * vec2( -1,  1 ) ).r;\r\n\r\n\t\t// second column\r\n\r\n\t\t\tfloat tx1y0 = texture2D( tDiffuse, vUv + texel * vec2(  0, -1 ) ).r;\r\n\t\t\tfloat tx1y1 = texture2D( tDiffuse, vUv + texel * vec2(  0,  0 ) ).r;\r\n\t\t\tfloat tx1y2 = texture2D( tDiffuse, vUv + texel * vec2(  0,  1 ) ).r;\r\n\r\n\t\t// third column\r\n\r\n\t\t\tfloat tx2y0 = texture2D( tDiffuse, vUv + texel * vec2(  1, -1 ) ).r;\r\n\t\t\tfloat tx2y1 = texture2D( tDiffuse, vUv + texel * vec2(  1,  0 ) ).r;\r\n\t\t\tfloat tx2y2 = texture2D( tDiffuse, vUv + texel * vec2(  1,  1 ) ).r;\r\n\r\n\t\t// gradient value in x direction\r\n\r\n\t\t\tfloat valueGx = Gx[0][0] * tx0y0 + Gx[1][0] * tx1y0 + Gx[2][0] * tx2y0 +\r\n\t\t\t\tGx[0][1] * tx0y1 + Gx[1][1] * tx1y1 + Gx[2][1] * tx2y1 +\r\n\t\t\t\tGx[0][2] * tx0y2 + Gx[1][2] * tx1y2 + Gx[2][2] * tx2y2;\r\n\r\n\t\t// gradient value in y direction\r\n\r\n\t\t\tfloat valueGy = Gy[0][0] * tx0y0 + Gy[1][0] * tx1y0 + Gy[2][0] * tx2y0 +\r\n\t\t\t\tGy[0][1] * tx0y1 + Gy[1][1] * tx1y1 + Gy[2][1] * tx2y1 +\r\n\t\t\t\tGy[0][2] * tx0y2 + Gy[1][2] * tx1y2 + Gy[2][2] * tx2y2;\r\n\r\n\t\t// magnitute of the total gradient\r\n\r\n\t\t\tfloat G = sqrt( ( valueGx * valueGx ) + ( valueGy * valueGy ) );\r\n\r\n\t\t\tgl_FragColor = vec4( vec3( G ), 1 );\r\n\r\n\t\t}`\r\n\r\n};\r\n\r\nexport { SobelOperatorShader };\r\n"],
  "mappings": ";;;;;AAWA,IAAM,sBAAsB;AAAA,EAE3B,UAAU;AAAA,IAET,YAAY,EAAE,OAAO,KAAK;AAAA,IAC1B,cAAc,EAAE,OAAO,IAAI,QAAQ,EAAE;AAAA,EAEtC;AAAA,EAEA,cAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYxB,gBAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAuD3B;",
  "names": []
}
